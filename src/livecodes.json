{
  "title": "astro-internal",
  "description": "",
  "tags": [],
  "activeEditor": "script",
  "markup": {
    "language": "html",
    "content": "",
    "contentUrl": "",
    "selector": ""
  },
  "style": {
    "language": "css",
    "content": "",
    "contentUrl": "",
    "selector": ""
  },
  "script": {
    "language": "typescript",
    "content": "export async function renderAstroComponent(component: InstanceType<typeof AstroComponent>) {\r\n  let template = '';\r\n\r\n  for await (const value of component) {\r\n    if (value || value === 0) {\r\n      template += value;\r\n    }\r\n  }\r\n\r\n  return template;\r\n}\r\n\r\nexport async function renderToString(result: any, componentFactory: AstroComponentFactory, props: any, children: any = {}) {\r\n  const Component = await componentFactory(result, props, children);\r\n  let template = await renderAstroComponent(Component);\r\n  return template\r\n}\r\n\r\nexport async function renderPage(result: any, Component: AstroComponentFactory, props: any, children: any) {\r\n  const template = await renderToString(result, Component, props, children);\r\n  const styles = Array.from(result.styles).map(style => renderElement('style', style as any));\r\n  const scripts = Array.from(result.scripts).map(script => renderElement('script', script as any));\r\n  return template.replace(\"</head>\", styles.join('\\n') + scripts.join('\\n') + \"</head>\");\r\n}\r\n\r\nfunction renderElement(name: string, { props: _props, children = ''}: { props: Record<any, any>, children?: string }) {\r\n  const { hoist: _, \"data-astro-id\": astroId, \"define:vars\": defineVars, ...props } = _props;\r\n  if (defineVars) {\r\n    if (name === 'style') {\r\n      children = defineStyleVars(astroId, defineVars) + '\\n' + children;\r\n    }\r\n    if (name === 'script') {\r\n      children = defineScriptVars(defineVars) + '\\n' + children;\r\n    }\r\n  }\r\n  return `<${name}${spreadAttributes(props)}>${children}</${name}>`\r\n}\r\n\r\nimport { valueToEstree, Value } from 'estree-util-value-to-estree';\r\nimport * as astring from 'astring';\r\nconst { generate, GENERATOR } = astring;\r\n// A more robust version alternative to `JSON.stringify` that can handle most values\r\n// see https://github.com/remcohaszing/estree-util-value-to-estree#readme\r\nconst customGenerator: astring.Generator = {\r\n  ...GENERATOR,\r\n  Literal(node, state) {\r\n    if (node.raw != null) {\r\n      // escape closing script tags in strings so browsers wouldn't interpret them as\r\n      // closing the actual end tag in HTML\r\n      state.write(node.raw.replace('</script>', '<\\\\/script>'));\r\n    } else {\r\n      GENERATOR.Literal(node, state);\r\n    }\r\n  },\r\n};\r\nconst serialize = (value: Value) =>\r\n  generate(valueToEstree(value), {\r\n    generator: customGenerator,\r\n  });\r\n\r\nasync function _render(child: any) {\r\n  child = await child;\r\n  if (Array.isArray(child)) {\r\n    return (await Promise.all(child.map(value => _render(value)))).join('\\n');\r\n  } else if (typeof child === 'function') {\r\n    // Special: If a child is a function, call it automatically.\r\n    // This lets you do {() => ...} without the extra boilerplate\r\n    // of wrapping it in a function and calling it.\r\n    return await child();\r\n  } else if (typeof child === 'string') {\r\n    return child;\r\n  } else if (!child && child !== 0) {\r\n    // do nothing, safe to ignore falsey values.\r\n  } else if (child instanceof AstroComponent) {\r\n    return await renderAstroComponent(child);\r\n  } else {\r\n    return child;\r\n  }\r\n}\r\n\r\nexport class AstroComponent {\r\n  private htmlParts: string[];\r\n  private expressions: TemplateStringsArray;\r\n  \r\n  constructor(htmlParts: string[], expressions: TemplateStringsArray) {\r\n    this.htmlParts = htmlParts;\r\n    this.expressions = expressions;\r\n  }\r\n\r\n  *[Symbol.iterator]() {\r\n    const { htmlParts, expressions } = this;\r\n\r\n    for (let i = 0; i < htmlParts.length; i++) {\r\n      const html = htmlParts[i];\r\n      const expression = expressions[i];\r\n\r\n      yield _render(html);\r\n      yield _render(expression);\r\n    }\r\n  }\r\n}\r\n\r\nexport function render(htmlParts: string[], ...expressions: TemplateStringsArray) {\r\n  return new AstroComponent(htmlParts, expressions);\r\n}\r\n\r\nexport interface AstroComponentFactory {\r\n  (result: any, props: any, slots: any): ReturnType<typeof render>;\r\n  isAstroComponentFactory?: boolean;\r\n}\r\n\r\nexport const createComponent = (cb: AstroComponentFactory) => {\r\n  // Add a flag to this callback to mark it as an Astro component\r\n  (cb as any).isAstroComponentFactory = true;\r\n  return cb;\r\n}\r\n\r\nfunction extractHydrationDirectives(inputProps: Record<string | number, any>): { hydrationDirective: [string, any] | null; props: Record<string | number, any> } {\r\n  let props: Record<string | number, any> = {};\r\n  let hydrationDirective: [string, any] | null = null;\r\n  for (const [key, value] of Object.entries(inputProps)) {\r\n    if (key.startsWith('client:')) {\r\n      hydrationDirective = [key.split(':')[1], value];\r\n    } else {\r\n      props[key] = value;\r\n    }\r\n  }\r\n  return { hydrationDirective, props };\r\n}\r\n\r\ninterface HydrateScriptOptions {\r\n  renderer: any;\r\n  astroId: string;\r\n  props: any;\r\n}\r\n\r\n/** For hydrated components, generate a <script type=\"module\"> to load the component */\r\nasync function generateHydrateScript(scriptOptions: HydrateScriptOptions, metadata: Required<AstroComponentMetadata>) {\r\n  const { renderer, astroId, props } = scriptOptions;\r\n  const { hydrate, componentUrl, componentExport } = metadata;\r\n\r\n  if (!componentExport) {\r\n    throw new Error(`Unable to resolve a componentExport for \"${metadata.displayName}\"! Please open an issue.`)\r\n  }\r\n\r\n  let hydrationSource = '';\r\n  if (renderer.hydrationPolyfills) {\r\n    hydrationSource += `await Promise.all([${renderer.hydrationPolyfills.map((src: string) => `\\n  import(\"${src}\")`).join(', ')}]);\\n`;\r\n  }\r\n\r\n  hydrationSource += renderer.source\r\n    ? `const [{ ${componentExport.value}: Component }, { default: hydrate }] = await Promise.all([import(\"${componentUrl}\"), import(\"${renderer.source}\")]);\r\n  return (el, children) => hydrate(el)(Component, ${serialize(props)}, children);\r\n`\r\n    : `await import(\"${componentUrl}\");\r\n  return () => {};\r\n`;\r\n\r\n  const hydrationScript = `<script type=\"module\">\r\nimport setup from 'astro/client/${hydrate}.js';\r\nsetup(\"${astroId}\", {${metadata.hydrateArgs ? `value: ${JSON.stringify(metadata.hydrateArgs)}` : ''}}, async () => {\r\n  ${hydrationSource}\r\n});\r\n</script>\r\n`;\r\n\r\n  return hydrationScript;\r\n}\r\n\r\nexport const renderSlot = async (result: any, slotted: string, fallback?: any) => {\r\n  if (slotted) {\r\n    return _render(slotted);\r\n  }\r\n  return fallback;\r\n};\r\n\r\nexport const renderComponent = async (result: any, displayName: string, Component: unknown, _props: Record<string | number, any>, children: any) => {\r\n  Component = await Component;\r\n  // children = await renderGenerator(children);\r\n  if (Component && (Component as any).isAstroComponentFactory) {\r\n    const output = await renderToString(result, (Component as any), _props, children)\r\n    return output;\r\n  }\r\n  // const { renderers } = result._metadata;\r\n  // let metadata: AstroComponentMetadata = { displayName };\r\n\r\n  // if (Component == null) {\r\n  //   throw new Error(`Unable to render ${metadata.displayName} because it is ${Component}!\\nDid you forget to import the component or is it possible there is a typo?`);\r\n  // }\r\n  // // else if (typeof Component === 'string' && !isCustomElementTag(Component)) {\r\n  // //   throw new Error(`Astro is unable to render ${metadata.displayName}!\\nIs there a renderer to handle this type of component defined in your Astro config?`);\r\n  // // }\r\n  // const { hydrationDirective, props } = extractHydrationDirectives(_props);\r\n  // let html = '';\r\n\r\n  // if (!hydrationDirective) {\r\n  //   return '<pre>Not implemented</pre>';\r\n  // }\r\n  // metadata.hydrate = hydrationDirective[0] as AstroComponentMetadata['hydrate'];\r\n  // metadata.hydrateArgs = hydrationDirective[1];\r\n\r\n  // for (const [url, exported] of Object.entries(result._metadata.importedModules)) {\r\n  //   for (const [key, value] of Object.entries(exported as any)) {\r\n  //     if (Component === value) {\r\n  //       metadata.componentExport = { value: key };\r\n  //       metadata.componentUrl = url;\r\n  //       break;\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  // let renderer = null;\r\n  // for (const r of renderers) {\r\n  //   if (await r.ssr.check(Component, props, null)) {\r\n  //     renderer = r;\r\n  //   }\r\n  // }\r\n\r\n  // ({ html } = await renderer.ssr.renderToStaticMarkup(Component, props, null));\r\n  // const astroId = shorthash.unique(html);\r\n\r\n  // result.scripts.add(await generateHydrateScript({ renderer, astroId, props }, metadata as Required<AstroComponentMetadata>));\r\n\r\n  // return `<astro-root uid=\"${astroId}\">${html}</astro-root>`;\r\n};\r\n\r\nexport const addAttribute = (value: any, key: string) => {\r\n  if (value == null || value === false) {\r\n    return '';\r\n  }\r\n  return ` ${key}=\"${value}\"`;\r\n};\r\n\r\nexport const spreadAttributes = (values: Record<any, any>) => {\r\n  let output = '';\r\n  for (const [key, value] of Object.entries(values)) {\r\n    output += addAttribute(value, key);\r\n  }\r\n  return output;\r\n};\r\n\r\nexport const defineStyleVars = (astroId: string, vars: Record<any, any>) => {\r\n  let output = '\\n';\r\n  for (const [key, value] of Object.entries(vars)) {\r\n    output += `  --${key}: ${value};\\n`;\r\n  }\r\n  return `.${astroId} {${output}}`;\r\n};\r\n\r\nexport const defineScriptVars = (vars: Record<any, any>) => {\r\n  let output = '';\r\n  for (const [key, value] of Object.entries(vars)) {\r\n    output += `let ${key} = ${JSON.stringify(value)};\\n`;\r\n  }\r\n  return output;\r\n};",
    "contentUrl": "",
    "selector": ""
  },
  "stylesheets": [],
  "scripts": [],
  "cssPreset": "",
  "processors": {
    "postcss": {
      "autoprefixer": false,
      "postcssPresetEnv": false,
      "tailwindcss": false
    }
  },
  "customSettings": {
    "template": {
      "data": {},
      "prerender": true
    }
  },
  "imports": {},
  "types": {},
  "version": "0.4.0"
}